# -*- coding: utf-8 -*-
"""Improved Clustering Code

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/16avRVnmgMzNc_JWSH0prvAYZFWxBtFFu
"""

import numpy as np
from matplotlib import pyplot as plt
from random import random
from scipy import stats

# Didnt need to do this by hand!!! numpy can make an array of random bools

def createLattice(size, prob):     # size must be an integer, prob must be a float 0<prob<1
  lattice = np.zeros([size+1,size+1])
  #states = np.random.rand([size,size])
  for row in lattice:  
    states = np.random.rand(size+1)
    row[(states<= prob)] = 1
    row[(states>prob)] = 0 
  return lattice

def showLattice(size,prob):
  lattice = createLattice(size,prob)
  lattice[int(size*0.4):int(size*0.6),:] = 1
  np.pad(lattice,1,mode="constant")
  clusters = np.zeros([size+1,size+1]) 
  n=1
  for i in range(1,size):
    for j in range(1,size):
      if lattice[i,j] ==1:
        clusters[i,j] = n
        n+=1
  #np.pad(clusters,1,mode="constant")
  plt.matshow(clusters, cmap='Blues')

showLattice(50,0.6)

def cleanUpLattice(size,prob,noiseSize, plot = True):
  #size = size+1
  trial = size * 2
  soln = False
  lattice = createLattice(size,prob)
  np.pad(lattice,1,mode="constant")
  lattice[int(size*0.4):int(size*0.6),:] = 1
  clusters = np.zeros([size+1,size+1])                    
  clusters[0,lattice[0,:]==1] = 1
  n=1
  for i in range(1,size):
    for j in range(1,size):
      if lattice[i,j] ==1:
        clusters[i,j] = n
        n+=1
  for x in range(trial):
    for i in range(1,size):
      for j in range(1,size):
        if clusters[i,j] != 0:
            if (clusters[i-1,j]==0 and clusters [i+1,j]==0) or (clusters[i,j-1]==0 and clusters[i,j+1]==0):
              clusters[i,j]=0
            else:
              mx = np.max([clusters[i,j], clusters[i,j-1],clusters[i,j+1],clusters[i-1,j],clusters[i+1,j]])
              if mx != clusters[i,j]:
                #print('change!'+str(mx))
                clusters[i,j] = mx
  vals,counts = np.unique(clusters, return_counts=True)
  for i in range(len(vals)):
    if counts[i] < noiseSize:
      clusters[vals[i]==clusters] = 0
  #index = np.argmax(counts)
  #print(vals[index])
  for item in clusters[size-1,:size]:
    #print(item)
    if item in clusters[1,:size] and item !=0:
      soln = True
      #print("solution possible")
  #plt.matshow(lattice[:size,:size],cmap = 'Reds')
  #plt.colorbar()
  if plot == True:
    plt.matshow(clusters, cmap='Blues')
    #plt.colorbar()
    plt.title(str(size)+' by '+str(size)+", "+str(prob*100)+'% Concentration')
  return soln

cleanUpLattice(50,0.5,60)

def stats(size,prob,length):
  results = np.full(length,False)
  for i in range(len(results)):
    results[i] = solveLattice(size,prob,plot=False)
  out = np.sum(results) / length
  return(out)

stats(20,0.6,20)

def probStats(size,length=30,step=0.05):
  data = np.array([])
  probs = np.arange(0,1,step)
  for prob in probs:
    data = np.append(data, stats(size,prob,length))
  plt.plot(probs,data,label = 'Matrix Size ='+str(size))

probStats(10)
probStats(20)
probStats(30)
plt.xlabel('Probability of any single site being permeable')
plt.ylabel('Probability of electron passing')
plt.legend()

probStats(3,length = 100)
probStats(30,length = 100)
plt.xlabel('Probability of any single site being permeable')
plt.ylabel('Probability of electron passing')
plt.legend()

probStats(1,length = 400)
x = np.arange(0,2)
plt.plot(x,x,label = 'y = x')
plt.xlabel('Probability of any single site being permeable')
plt.ylabel('Probability of electron passing')
plt.legend()

